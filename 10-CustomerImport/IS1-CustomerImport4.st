Object subclass: #Address	instanceVariableNames: 'id streetName streetNumber town zipCode province'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Address methodsFor: 'twon' stamp: 'HernanWilkinson 10/28/2016 16:07'!town: aTown 	town := aTown! !!Address methodsFor: 'twon' stamp: 'HernanWilkinson 10/28/2016 16:12'!town	^town! !!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:13'!zipCode	^zipCode! !!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:08'!zipCode: aZipCode 	zipCode := aZipCode! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:08'!province: aProvince 	province := aProvince	! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:11'!province	^province! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetName	^streetName ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetNumber	^streetNumber ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetNumber: aStreetNumber 	streetNumber := aStreetNumber ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetName: aStreetName 	streetName := aStreetName ! !!Address methodsFor: 'testing' stamp: 'HernanWilkinson 11/1/2016 10:06'!isAt: aStreetName	^streetName = aStreetName ! !TestCase subclass: #CustomerImportTest	instanceVariableNames: 'importer system'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:53'!customerRecordWithMoreThanFiveFieldsTestData		^ ReadStream on: self alwaysImportedCustomerRecord,',x'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:47'!alwaysImportedCustomerRecord	^ 'C,Pepe,Sanchez,', self alwaysImportedCustomerIdType, ',', self alwaysImportedCustomerIdNumber ! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:47'!alwaysImportedCustomerIdNumber	^ '22333444'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/3/2016 09:21'!alwaysImportedCustomer	| anIdentificationNumber anIdentifycationType |	anIdentifycationType := self alwaysImportedCustomerIdType.	anIdentificationNumber := self alwaysImportedCustomerIdNumber.	^ system		customerIdentifiedAs: anIdentifycationType		numbered: anIdentificationNumber! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:50'!customerRecordWithLessThanFiveFieldsTestData		^ ReadStream on: 'C,Pepe,Sanchez,D'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/1/2016 17:48'!customerRecordStartingWithMoreThanOneCTestData		^ ReadStream on:'CC,Pepe,Sanchez,D,22333444'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:46'!alwaysImportedCustomerIdType	^ 'D'! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 11:00'!assert: customer hasAddressAt: streetName number: streetNumber in: town zipCode: zipCode province: province	| address |		address := customer addressAt: streetName ifNone: [ self fail ].	self assert: address streetName equals: streetName.	self assert: address streetNumber equals: streetNumber.	self assert: address town equals: town.	self assert: address zipCode equals: zipCode.	self assert: address province equals: province.	! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/3/2016 09:10'!assertImportedCustomersSizeIsCorrect	self assert: system allCustomers size equals: 2! !!CustomerImportTest methodsFor: 'asserting' stamp: 'MalenaIvnisky 7/2/2018 12:46'!assert: customer isNamed: firstName lastName: lastName identifiedAs: idType withNumber: idNumber andNumberOfAddresses: addressesSize	self assert: customer firstName equals: firstName.	self assert: customer lastName equals: lastName.	self assert: customer identificationType equals: idType.	self assert: customer identificationNumber equals: idNumber.	self assert: customer numberOfAddresses equals: addressesSize .! !!CustomerImportTest methodsFor: 'asserting' stamp: 'MalenaIvnisky 7/2/2018 12:46'!assertPepeSanchezWasImportedCorrectly	| customer |	customer := self alwaysImportedCustomer. 		self assert: customer isNamed: 'Pepe' lastName: 'Sanchez' identifiedAs: self alwaysImportedCustomerIdType withNumber: self alwaysImportedCustomerIdNumber andNumberOfAddresses: 2.	self assert: customer hasAddressAt: 'San Martin' number: 3322 in: 'Olivos' zipCode: 1636 province: 'BsAs'.	self assert: customer hasAddressAt: 'Maipu' number: 888 in: 'Florida' zipCode: 1122 province: 'Buenos Aires'! !!CustomerImportTest methodsFor: 'asserting' stamp: 'MalenaIvnisky 7/2/2018 12:46'!assertJuanPerezWasImportedCorrectly	| customer idType idNumber |	idType := 'C'.	idNumber := '23-25666777-9'.	customer := system customerIdentifiedAs: idType numbered: idNumber.	self		assert: customer		isNamed: 'Juan'		lastName: 'Perez'		identifiedAs: idType		withNumber: idNumber		andNumberOfAddresses: 1.	self		assert: customer		hasAddressAt: 'Alem'		number: 1122		in: 'CABA'		zipCode: 1001		province: 'CABA'! !!CustomerImportTest methodsFor: 'testing' stamp: 'HernanWilkinson 11/2/2016 10:41'!testCanNotImportAddressRecordWithLessThanSixFields		self		should: [ self importCustomersFrom: self addressRecordWithLessThanSixFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self assert: anError messageText equals: CustomerImporter invalidAddressRecordErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'MalenaIvnisky 7/2/2018 11:31'!testShouldNotImportCustomerRecordsStartingWithMoreThanC	self		should: [ self				importCustomersFrom: self customerRecordStartingWithMoreThanOneCTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: CustomerImporter invalidRecordTypeErrorDescription.			self assert: system isEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'HernanWilkinson 11/1/2016 15:56'!testImportCustomers	self importCustomersFrom: self validTestData.	self assertImportedCustomersSizeIsCorrect.	self assertPepeSanchezWasImportedCorrectly.	self assertJuanPerezWasImportedCorrectly! !!CustomerImportTest methodsFor: 'testing' stamp: 'MalenaIvnisky 7/2/2018 11:31'!testCanNotImportAddressWithoutCustomer	self		should: [ self importCustomersFrom: self addressWithoutCustomerTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: CustomerImporter addressWithoutCustomerErrorDescription.			self assert: system isEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'HernanWilkinson 11/2/2016 15:52'!testEmptyLinesAreRecognizedAsInvalidRecords		self		should: [ self importCustomersFrom: self dataWithEmptyLine ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self assert: anError messageText equals: CustomerImporter invalidRecordTypeErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'MalenaIvnisky 7/2/2018 11:31'!testCanNotImportCustomerRecordWithMoreThanFiveFields	self		should: [ self				importCustomersFrom: self customerRecordWithMoreThanFiveFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: CustomerImporter invalidCustomerRecordErrorDescription.			self assert: system isEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'HernanWilkinson 11/2/2016 10:42'!testCanNotImportAddressRecordWithMoreThanSixFields	self 		should: [ self importCustomersFrom: self addressRecordWithMoreThanSixFieldsTestData ]		raise: Error - MessageNotUnderstood 		withExceptionDo: [ :anError | 			self assert: anError messageText equals: CustomerImporter invalidAddressRecordErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]	! !!CustomerImportTest methodsFor: 'testing' stamp: 'HernanWilkinson 11/2/2016 10:42'!testShouldNotImportAddressRecordsStartingWithMoreThanA	self 		should: [ self importCustomersFrom: self addressRecordStartingWithMoreThanOneATestData ]		raise: Error - MessageNotUnderstood 		withExceptionDo: [ :anError | 			self assert: anError messageText equals: CustomerImporter invalidRecordTypeErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]	! !!CustomerImportTest methodsFor: 'testing' stamp: 'MalenaIvnisky 7/2/2018 11:31'!testCanNotImportCustomerRecordWithLessThanFiveFields	self		should: [ self				importCustomersFrom: self customerRecordWithLessThanFiveFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: CustomerImporter invalidCustomerRecordErrorDescription.			self assert: system isEmpty ]! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/2/2016 10:45'!addressRecordWithLessThanSixFieldsTestData		^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636'! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/2/2016 10:45'!addressRecordStartingWithMoreThanOneATestData		^ ReadStream on: self alwaysImportedCustomerRecord,'AA,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/2/2016 10:45'!addressRecordWithMoreThanSixFieldsTestData		^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAs,y otra cosa'! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/1/2016 15:59'!addressWithoutCustomerTestData		^ ReadStream on: 'A,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'test data' stamp: 'HernanWilkinson 11/2/2016 15:52'!dataWithEmptyLine		^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'test data' stamp: 'HernanWilkinson 11/2/2016 10:46'!validTestData	^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!CustomerImportTest methodsFor: 'importing' stamp: 'HernanWilkinson 11/4/2016 09:27'!importCustomersFrom: inputStream	(CustomerImporter from: inputStream using: system) import! !!CustomerImportTest methodsFor: 'setup-teardown' stamp: 'HernanWilkinson 11/4/2016 09:51'!setUp	system := Environment current createCustomerSystem.	system start.	system beginTransaction! !!CustomerImportTest methodsFor: 'setup-teardown' stamp: 'HernanWilkinson 11/4/2016 09:52'!tearDown	system commit.	system shutdown! !Object subclass: #Environment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Environment methodsFor: 'system creation' stamp: 'HernanWilkinson 11/4/2016 09:49'!createCustomerSystem	self subclassResponsibility ! !!Environment methodsFor: 'system creation' stamp: 'MalenaIvnisky 7/2/2018 12:16'!createSupplierSystem	self subclassResponsibility ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Environment class	instanceVariableNames: ''!!Environment class methodsFor: 'enviroment selection' stamp: 'HernanWilkinson 11/4/2016 09:46'!current		^self allSubclasses 		detect: [ :anEnvironemntClass | anEnvironemntClass isCurrent ]		ifFound: [ :anEnvironmentClass | anEnvironmentClass new ]		ifNone: [ self error: 'No environment detected' ]! !!Environment class methodsFor: 'enviroment selection' stamp: 'HernanWilkinson 11/4/2016 09:49'!isCurrent	self subclassResponsibility ! !Environment subclass: #DevelpmentEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!DevelpmentEnvironment methodsFor: 'as yet unclassified' stamp: 'MalenaIvnisky 7/2/2018 11:27'!createCustomerSystem		^TransientCustomerSystem new! !!DevelpmentEnvironment methodsFor: 'as yet unclassified' stamp: 'MalenaIvnisky 7/2/2018 12:16'!createSupplierSystem		^TransientSupplierSystem new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DevelpmentEnvironment class	instanceVariableNames: ''!!DevelpmentEnvironment class methodsFor: 'as yet unclassified' stamp: 'HernanWilkinson 11/4/2016 09:47'!isCurrent		^IntegrationEnvironment isCurrent not! !Environment subclass: #IntegrationEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!IntegrationEnvironment methodsFor: 'as yet unclassified' stamp: 'HernanWilkinson 11/4/2016 09:45'!createCustomerSystem		^PersistentCustomerSystem new! !!IntegrationEnvironment methodsFor: 'as yet unclassified' stamp: 'MalenaIvnisky 7/2/2018 12:16'!createSupplierSystem		^PersistentSupplierSystem new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!IntegrationEnvironment class	instanceVariableNames: ''!!IntegrationEnvironment class methodsFor: 'testing' stamp: 'MalenaIvnisky 7/2/2018 13:03'!isCurrent		^false! !Object subclass: #Party	instanceVariableNames: 'identification addresses'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Party methodsFor: 'identification' stamp: 'MalenaIvnisky 6/29/2018 17:14'!identificationNumber: anIdentificationNumber 	identification number: anIdentificationNumber! !!Party methodsFor: 'identification' stamp: 'MalenaIvnisky 6/29/2018 17:15'!isIdentifiedAs: anIdType numbered: anIdNumber 		^identification isOfType: anIdType andNumber: anIdNumber! !!Party methodsFor: 'identification' stamp: 'MalenaIvnisky 6/29/2018 17:14'!identificationNumber		^ identification number! !!Party methodsFor: 'identification' stamp: 'MalenaIvnisky 6/29/2018 17:15'!identificationType: anIdentificationType 	identification type: anIdentificationType! !!Party methodsFor: 'identification' stamp: 'MalenaIvnisky 6/29/2018 17:14'!identificationType		^identification type! !!Party methodsFor: 'addresses' stamp: 'MalenaIvnisky 6/29/2018 16:16'!addressAt: aStreetName ifNone: noneClosure 		^addresses detect: [ :anAddress | anAddress isAt: aStreetName ] ifNone: noneClosure ! !!Party methodsFor: 'addresses' stamp: 'MalenaIvnisky 6/29/2018 16:16'!addressesIsEmpty		^addresses isEmpty! !!Party methodsFor: 'addresses' stamp: 'MalenaIvnisky 6/29/2018 16:15'!numberOfAddresses		^addresses size! !!Party methodsFor: 'addresses' stamp: 'MalenaIvnisky 6/29/2018 16:16'!addresses	^ addresses! !!Party methodsFor: 'addresses' stamp: 'MalenaIvnisky 6/29/2018 16:15'!addAddress: anAddress 	addresses add: anAddress ! !Party subclass: #Customer	instanceVariableNames: 'firstName lastName id'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 13:09'!lastName: aLastName 	lastName := aLastName! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!firstName		^firstName ! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!lastName	^lastName ! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 13:09'!firstName: aName 	firstName := aName! !!Customer methodsFor: 'initialization' stamp: 'MalenaIvnisky 6/29/2018 17:16'!initialize	super initialize.	addresses := OrderedCollection new.	identification := PartyIdentification new.! !Object subclass: #PartyIdentification	instanceVariableNames: 'number type'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!PartyIdentification methodsFor: 'accessing' stamp: 'MalenaIvnisky 6/29/2018 17:07'!number	^ number! !!PartyIdentification methodsFor: 'accessing' stamp: 'MalenaIvnisky 6/29/2018 17:09'!number: anIdentificationNumber	number := anIdentificationNumber! !!PartyIdentification methodsFor: 'accessing' stamp: 'MalenaIvnisky 6/29/2018 17:10'!type: anIdentificationType	type := anIdentificationType! !!PartyIdentification methodsFor: 'accessing' stamp: 'MalenaIvnisky 6/29/2018 17:08'!type	^ type! !!PartyIdentification methodsFor: 'comparing' stamp: 'MalenaIvnisky 6/29/2018 17:13'!isOfType: anIdentificationType andNumber: anIdentificationNumber	^ self type = anIdentificationType and: [ self number = anIdentificationNumber ]! !Object subclass: #PartyImporter	instanceVariableNames: 'line readStream record newParty'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!PartyImporter methodsFor: 'testing' stamp: 'MaleyDK 7/2/2018 00:29'!isAddressRecord	^ record first = 'A'! !!PartyImporter methodsFor: 'testing' stamp: 'MaleyDK 7/2/2018 00:07'!canImportNextLine	line := readStream nextLine.	^ line notNil! !!PartyImporter methodsFor: 'importing - private - address' stamp: 'MaleyDK 7/2/2018 00:27'!assertThereIsPartyForAddress	newParty isNil ifTrue: [ self signalAddressWithoutPartyError ].	! !!PartyImporter methodsFor: 'importing - private - address' stamp: 'MaleyDK 7/2/2018 00:32'!assertValidAddressRecordSize		record size ~= 6 ifTrue: [ self signalInvalidAddressRecord ].	! !!PartyImporter methodsFor: 'importing - private - address' stamp: 'MaleyDK 7/2/2018 00:20'!importAddress	| newAddress |	self assertThereIsPartyForAddress.	self assertValidAddressRecordSize.		newAddress := Address new.	newAddress streetName: record second.	newAddress streetNumber: record third asInteger.	newAddress town: record fourth.	newAddress zipCode: record fifth asInteger.	newAddress province: record sixth.	^ newParty addAddress: newAddress! !!PartyImporter methodsFor: 'importing' stamp: 'MaleyDK 7/2/2018 00:06'!import	[ self canImportNextLine ] whileTrue: [ 		self convertLineToRecord.		self importRecord ]! !!PartyImporter methodsFor: 'importing - private' stamp: 'MalenaIvnisky 6/29/2018 16:36'!importRecord
	self subclassResponsibility! !!PartyImporter methodsFor: 'importing - private' stamp: 'MaleyDK 7/2/2018 00:08'!convertLineToRecord	record := line substrings: {$,}.		self assertRecordNotEmpty! !!PartyImporter methodsFor: 'importing - private' stamp: 'MaleyDK 7/2/2018 00:37'!assertRecordNotEmpty		record isEmpty ifTrue: [ self signalInvalidRecordType ]! !!PartyImporter methodsFor: 'importing - private - party' stamp: 'MaleyDK 7/2/2018 00:46'!assertValidPartyRecordSize		record size ~= (self validPartyRecordSize) ifTrue: [ self signalInvalidPartyRecord ].	! !!PartyImporter methodsFor: 'importing - private - party' stamp: 'MaleyDK 7/2/2018 00:46'!validPartyRecordSize	self subclassResponsibility ! !!PartyImporter methodsFor: 'signalling' stamp: 'MaleyDK 7/2/2018 00:10'!signalInvalidRecordType	self error: self class invalidRecordTypeErrorDescription! !!PartyImporter methodsFor: 'signalling' stamp: 'MaleyDK 7/2/2018 00:27'!signalAddressWithoutPartyError	self subclassResponsibility ! !!PartyImporter methodsFor: 'signalling' stamp: 'MaleyDK 7/2/2018 00:44'!signalInvalidPartyRecord	self subclassResponsibility ! !!PartyImporter methodsFor: 'error signal' stamp: 'MaleyDK 7/2/2018 00:32'!signalInvalidAddressRecord 		self error: self class invalidAddressRecordErrorDescription ! !!PartyImporter methodsFor: 'initialization' stamp: 'MalenaIvnisky 6/29/2018 16:36'!initializeOn: aReadStream using: aCustomerSystem
	self subclassResponsibility! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PartyImporter class	instanceVariableNames: ''!!PartyImporter class methodsFor: 'instance creation' stamp: 'MalenaIvnisky 6/29/2018 16:36'!from: aReadStream using: aCustomerSystem
	self subclassResponsibility! !!PartyImporter class methodsFor: 'error descriptions' stamp: 'MaleyDK 7/2/2018 00:33'!invalidAddressRecordErrorDescription		^'Invalid address record'! !!PartyImporter class methodsFor: 'error descriptions' stamp: 'MalenaIvnisky 6/29/2018 17:23'!invalidRecordTypeErrorDescription		^'Invalid record type'! !PartyImporter subclass: #CustomerImporter	instanceVariableNames: 'system'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!CustomerImporter methodsFor: 'importing - private' stamp: 'HernanWilkinson 11/1/2016 17:52'!importRecord		self isCustomerRecord ifTrue: [ ^self importCustomer ].	self isAddressRecord ifTrue: [ ^self importAddress ].		self signalInvalidRecordType! !!CustomerImporter methodsFor: 'importing - private' stamp: 'MaleyDK 7/2/2018 00:43'!importCustomer	self assertValidPartyRecordSize.	newParty := Customer new.	newParty firstName: record second.	newParty lastName: record third.	newParty identificationType: record fourth.	newParty identificationNumber: record fifth.	system add: newParty! !!CustomerImporter methodsFor: 'importing - private' stamp: 'MaleyDK 7/2/2018 00:45'!validPartyRecordSize	^ 5! !!CustomerImporter methodsFor: 'initialization' stamp: 'HernanWilkinson 11/4/2016 09:26'!initializeOn: aReadStream using: aCustomerSystem	readStream := aReadStream.	system := aCustomerSystem! !!CustomerImporter methodsFor: 'testing' stamp: 'HernanWilkinson 11/2/2016 10:55'!isCustomerRecord	^ record first = 'C'! !!CustomerImporter methodsFor: 'error signal' stamp: 'MaleyDK 7/2/2018 00:27'!signalAddressWithoutPartyError	self error: self class addressWithoutCustomerErrorDescription.! !!CustomerImporter methodsFor: 'error signal' stamp: 'MaleyDK 7/2/2018 00:44'!signalInvalidPartyRecord 		self error: self class invalidCustomerRecordErrorDescription ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CustomerImporter class	instanceVariableNames: ''!!CustomerImporter class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/4/2016 09:27'!from: aReadStream using: aCustomerSystem	^ self new initializeOn: aReadStream using: aCustomerSystem! !!CustomerImporter class methodsFor: 'error descriptions' stamp: 'MaleyDK 7/2/2018 00:26'!addressWithoutCustomerErrorDescription		^'There is no customer for the imported address'! !!CustomerImporter class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 11/2/2016 10:51'!invalidCustomerRecordErrorDescription		^'Invalid customer record'! !Object subclass: #StorageSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!StorageSystem methodsFor: 'system live cycle' stamp: 'HernanWilkinson 11/4/2016 09:51'!start	self subclassResponsibility! !!StorageSystem methodsFor: 'system live cycle' stamp: 'HernanWilkinson 11/4/2016 09:52'!shutdown	self subclassResponsibility! !!StorageSystem methodsFor: 'transaction' stamp: 'HernanWilkinson 11/4/2016 09:35'!commit	self subclassResponsibility! !!StorageSystem methodsFor: 'transaction' stamp: 'HernanWilkinson 11/4/2016 09:35'!beginTransaction	self subclassResponsibility! !!StorageSystem methodsFor: 'customers' stamp: 'MalenaIvnisky 7/2/2018 11:31'!isEmpty	self subclassResponsibility! !!StorageSystem methodsFor: 'customers' stamp: 'MalenaIvnisky 6/26/2018 20:27'!add: aCustomer	self subclassResponsibility! !StorageSystem subclass: #PersistentStorageSystem	instanceVariableNames: 'session'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!PersistentStorageSystem methodsFor: 'system live cycle' stamp: 'MalenaIvnisky 7/2/2018 12:00'!start	session start! !!PersistentStorageSystem methodsFor: 'system live cycle' stamp: 'MalenaIvnisky 7/2/2018 12:00'!shutdown	session shutdown! !!PersistentStorageSystem methodsFor: 'as yet unclassified' stamp: 'MalenaIvnisky 7/2/2018 12:07'!partyIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ofType: aPartyClass	| parties |	parties := session		select: [ :aParty | 			aParty identificationType = anIdentifycationType				and: [ aParty identificationNumber = anIdentificationNumber ] ]		ofType: aPartyClass.	parties size = 1		ifFalse: [ self error: 'No or more that one ', (aPartyClass className) , ' found' ].	^ parties anyOne! !!PersistentStorageSystem methodsFor: 'customers' stamp: 'MalenaIvnisky 7/2/2018 11:56'!add: anEntity	session persist: anEntity ! !!PersistentStorageSystem methodsFor: 'mapping' stamp: 'MalenaIvnisky 7/2/2018 12:12'!customerMapping	^ ClassMapping		withDefaultTableNameFor: Customer		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #firstName)				with: (EmbededMapping withDefaultFieldNameFor: #lastName)				with: (EmbededMapping withDefaultFieldNameFor: #identification)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !!PersistentStorageSystem methodsFor: 'mapping' stamp: 'MalenaIvnisky 7/2/2018 11:56'!addressMapping	^ ClassMapping		withDefaultTableNameFor: Address		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #streetName)				with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)				with: (EmbededMapping withDefaultFieldNameFor: #town)				with: (EmbededMapping withDefaultFieldNameFor: #zipCode)				with: (EmbededMapping withDefaultFieldNameFor: #province))! !!PersistentStorageSystem methodsFor: 'initialization' stamp: 'MalenaIvnisky 7/2/2018 11:58'!initialize		super initialize.	self initializeSession. ! !!PersistentStorageSystem methodsFor: 'initialization' stamp: 'MalenaIvnisky 7/2/2018 12:14'!initializeSession	self subclassResponsibility ! !!PersistentStorageSystem methodsFor: 'transaction' stamp: 'MalenaIvnisky 7/2/2018 11:56'!commit	session commit! !!PersistentStorageSystem methodsFor: 'transaction' stamp: 'MalenaIvnisky 7/2/2018 11:56'!beginTransaction	session beginTransaction! !PersistentStorageSystem subclass: #PersistentCustomerSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!PersistentCustomerSystem methodsFor: 'initialization' stamp: 'HernanWilkinson 11/4/2016 09:19'!initializeSession	session := DataBaseSession		for: (Array with: self addressMapping with: self customerMapping)! !!PersistentCustomerSystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:18'!allCustomers	^ session selectAllOfType: Customer! !!PersistentCustomerSystem methodsFor: 'customers' stamp: 'MalenaIvnisky 7/2/2018 12:08'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	^ self partyIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ofType: Customer! !!PersistentCustomerSystem methodsFor: 'customers' stamp: 'MalenaIvnisky 7/2/2018 11:31'!isEmpty	^ self allCustomers isEmpty! !PersistentStorageSystem subclass: #PersistentSupplierSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!PersistentSupplierSystem methodsFor: 'as yet unclassified' stamp: 'MalenaIvnisky 7/2/2018 12:03'!supplierMapping	^ ClassMapping		withDefaultTableNameFor: Supplier		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #fullName)				with: (EmbededMapping withDefaultFieldNameFor: #identification)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address)				with: (OneToManyMapping withDefaultFieldNameFor: #customers ofType: Customer))! !!PersistentSupplierSystem methodsFor: 'as yet unclassified' stamp: 'MalenaIvnisky 7/2/2018 12:04'!allSuppliers	^ session selectAllOfType: Supplier! !!PersistentSupplierSystem methodsFor: 'as yet unclassified' stamp: 'MalenaIvnisky 7/2/2018 12:09'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	^ self partyIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ofType: Supplier! !!PersistentSupplierSystem methodsFor: 'initialization' stamp: 'MalenaIvnisky 7/2/2018 12:12'!initializeSession	session := DataBaseSession		for: (Array with: self customerMapping with: self addressMapping with: self supplierMapping)! !!PersistentSupplierSystem methodsFor: 'testing' stamp: 'MalenaIvnisky 7/2/2018 12:13'!isEmpty	^ self allSuppliers isEmpty! !Party subclass: #Supplier	instanceVariableNames: 'fullName customers id'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Supplier methodsFor: 'initialization' stamp: 'MalenaIvnisky 6/29/2018 17:53'!initialize	super initialize.	addresses := OrderedCollection new.	customers := OrderedCollection new.	identification := PartyIdentification new.! !!Supplier methodsFor: 'customers' stamp: 'MalenaIvnisky 6/29/2018 17:54'!addCustomer: aCustomer		customers add: aCustomer! !!Supplier methodsFor: 'customers' stamp: 'MalenaIvnisky 7/2/2018 12:44'!numberOfCustomers	^ customers size! !!Supplier methodsFor: 'customers' stamp: 'MalenaIvnisky 7/2/2018 12:55'!customerIdentifiedAs: anIdentificationType numbered: anIdentificationNumber ifNone: noneClosure 		^customers detect: [ :aCustomer | aCustomer isIdentifiedAs: anIdentificationType numbered: anIdentificationNumber ] ifNone: noneClosure ! !!Supplier methodsFor: 'name' stamp: 'MalenaIvnisky 6/29/2018 16:20'!fullName	^ fullName! !!Supplier methodsFor: 'name' stamp: 'MalenaIvnisky 6/29/2018 16:20'!fullName: aFullName	fullName := aFullName ! !TestCase subclass: #SupplierImportTest	instanceVariableNames: 'importer customerSystem supplierSystem'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!SupplierImportTest methodsFor: 'running' stamp: 'MalenaIvnisky 7/2/2018 12:40'!tearDown	customerSystem commit.	customerSystem shutdown.		supplierSystem commit.	supplierSystem shutdown.! !!SupplierImportTest methodsFor: 'asserting' stamp: 'ndecarli 7/2/2018 15:58'!assertSupplier1HasExistingCustomer2	self assertSupplier1HasExistingCustomerWithIdNumber: self existingCustomer2IdentificationNumber.! !!SupplierImportTest methodsFor: 'asserting' stamp: 'ndecarli 7/2/2018 15:31'!assert: supplier isNamed: fullName identifiedAs: idType withNumber: idNumber numberOfAddresses: addressesSize andNumberOfCustomers: customersSize	self assert: supplier isNamed: fullName identifiedAs: idType withNumber: idNumber.	self assert: supplier numberOfAddresses equals: addressesSize.	self assert: supplier numberOfCustomers equals: customersSize.! !!SupplierImportTest methodsFor: 'asserting' stamp: 'ndecarli 7/2/2018 15:43'!defaultNumberOfNewCustomersForSupplier1	^1! !!SupplierImportTest methodsFor: 'asserting' stamp: 'ndecarli 7/2/2018 15:31'!assert: supplier isNamed: fullName identifiedAs: idType withNumber: idNumber	self assert: supplier fullName equals: fullName.	self assert: supplier identificationType equals: idType.	self assert: supplier identificationNumber equals: idNumber.! !!SupplierImportTest methodsFor: 'asserting' stamp: 'ndecarli 7/2/2018 15:51'!assertSupplier1WasImportedCorrectly	| supplier idType idNumber |		self assertSupplier1HasCorrectDataAndNumberOfAddresses: 2 andNumberOfCustomers: 2.	idType := 'D'.	idNumber := '123'.	supplier := supplierSystem supplierIdentifiedAs: idType numbered: idNumber.	self		assert: supplier		hasAddressAt: 'San Martin'		number: 3322		in: 'Olivos'		zipCode: 1636		province: 'BsAs'.	self		assert: supplier		hasAddressAt: 'Maipu'		number: 888		in: 'Florida'		zipCode: 1122		province: 'Buenos Aires'.	self		assert: supplier 		hasCustomerNamed: 'Pepe'		lastName: 'Sanchez'		identifiedAs: 'D'		numbered: self newCustomer1IdentificationNumber.	self		assert: supplier 		hasCustomerNamed: self existingCustomerName 		lastName: self existingCustomerLastName 		identifiedAs: self existingCustomerIdentificationType 		numbered: self existingCustomer1IdentificationNumber.! !!SupplierImportTest methodsFor: 'asserting' stamp: 'ndecarli 7/2/2018 15:47'!assertSupplier1HasNewCustomer1	| supplier idType idNumber |	idType := 'D'.	idNumber := '123'.	supplier := supplierSystem supplierIdentifiedAs: idType numbered: idNumber.	self		assert: supplier 		hasCustomerNamed: 'Pepe'		lastName: 'Sanchez'		identifiedAs: 'D'		numbered: self newCustomer1IdentificationNumber.! !!SupplierImportTest methodsFor: 'asserting' stamp: 'ndecarli 7/2/2018 15:08'!assertAmountOfStoredCustomersIs: aQuantity	^self assert: (self amountOfStoredCustomers = aQuantity).! !!SupplierImportTest methodsFor: 'asserting' stamp: 'ndecarli 7/2/2018 15:57'!assertSupplier1HasExistingCustomerWithIdNumber: anIdNumberAsString	| supplier idType idNumber |	idType := 'D'.	idNumber := '123'.	supplier := supplierSystem supplierIdentifiedAs: idType numbered: idNumber.	self		assert: supplier 		hasCustomerNamed: self existingCustomerName		lastName: self existingCustomerLastName		identifiedAs: self existingCustomerIdentificationType		numbered: anIdNumberAsString.! !!SupplierImportTest methodsFor: 'asserting' stamp: 'ndecarli 7/2/2018 15:38'!assertSupplier1HasCorrectDataAndNumberOfAddresses: addressesSize andNumberOfCustomers: customersSize		| supplier idType idNumber |	idType := 'D'.	idNumber := '123'.	supplier := supplierSystem supplierIdentifiedAs: idType numbered: idNumber.	self assert: supplier isNamed: 'Supplier1' identifiedAs: idType withNumber: idNumber numberOfAddresses: addressesSize andNumberOfCustomers: customersSize.! !!SupplierImportTest methodsFor: 'asserting' stamp: 'ndecarli 7/2/2018 14:58'!amountOfStoredCustomers	^customerSystem allCustomers size! !!SupplierImportTest methodsFor: 'asserting' stamp: 'ndecarli 7/2/2018 15:44'!defaultNumberOfCustomersForSupplier1	^ self defaultNumberOfExistingCustomersForSupplier1 + self defaultNumberOfNewCustomersForSupplier1! !!SupplierImportTest methodsFor: 'asserting' stamp: 'ndecarli 7/2/2018 15:43'!defaultNumberOfExistingCustomersForSupplier1	^1! !!SupplierImportTest methodsFor: 'asserting' stamp: 'MalenaIvnisky 7/2/2018 12:34'!assert: supplier hasAddressAt: streetName number: streetNumber in: town zipCode: zipCode province: province	| address |		address := supplier addressAt: streetName ifNone: [ self fail ].	self assert: address streetName equals: streetName.	self assert: address streetNumber equals: streetNumber.	self assert: address town equals: town.	self assert: address zipCode equals: zipCode.	self assert: address province equals: province.! !!SupplierImportTest methodsFor: 'asserting' stamp: 'ndecarli 7/2/2018 16:17'!assertSupplier1HasExistingCustomer1	self assertSupplier1HasExistingCustomerWithIdNumber: self existingCustomer1IdentificationNumber.! !!SupplierImportTest methodsFor: 'asserting' stamp: 'ndecarli 7/2/2018 15:47'!assertSupplier1HasNewCustomer2	| supplier idType idNumber |	idType := 'D'.	idNumber := '123'.	supplier := supplierSystem supplierIdentifiedAs: idType numbered: idNumber.	self		assert: supplier 		hasCustomerNamed: 'Pepe'		lastName: 'Sanchez'		identifiedAs: 'D'		numbered: self newCustomer2IdentificationNumber.! !!SupplierImportTest methodsFor: 'asserting' stamp: 'MalenaIvnisky 7/2/2018 12:59'!assert: supplier hasCustomerNamed: firstName lastName: lastName identifiedAs: identificationType numbered: identificationNumber	| customer |		customer := supplier customerIdentifiedAs: identificationType numbered: identificationNumber ifNone: [ self fail ].	self assert: customer firstName equals: firstName.	self assert: customer lastName equals: lastName.	self assert: customer identificationType equals: identificationType.	self assert: customer identificationNumber equals: identificationNumber.! !!SupplierImportTest methodsFor: 'asserting' stamp: 'ndecarli 7/2/2018 14:40'!assertAmountOfSuccessfullyImportedSuppliersIs: aQuantity	self assert: supplierSystem allSuppliers size equals: aQuantity! !!SupplierImportTest methodsFor: 'asserting' stamp: 'ndecarli 7/2/2018 15:41'!defaultNumberOfAddressesForSupplier1	^2! !!SupplierImportTest methodsFor: 'asserting' stamp: 'ndecarli 7/2/2018 14:35'!assertSupplier2WasImportedCorrectly	| supplier idType idNumber |		"S,Supplier2,C,23-25666777-9NC,Juan,Perez,C,', self newCustomerIdentificationNumber, 'A,Diaz Velez,666,Almagro,666,BsAs'"	idType := 'C'.	idNumber := '23-25666777-9'.	supplier := supplierSystem supplierIdentifiedAs: idType numbered: idNumber.	self		assert: supplier		isNamed: 'Supplier2'		identifiedAs: idType		withNumber: idNumber		numberOfAddresses: 1		andNumberOfCustomers: 1.	self		assert: supplier		hasAddressAt: 'Diaz Velez'		number: 666		in: 'Almagro'		zipCode: 666		province: 'BsAs'.	self		assert: supplier 		hasCustomerNamed: 'Carlos'		lastName: 'Tevez'		identifiedAs: 'C'		numbered: self newCustomer1IdentificationNumber.! !!SupplierImportTest methodsFor: 'instance creation' stamp: 'ndecarli 7/2/2018 14:18'!supplierRecordWithLessThanFourFieldsTestData    ^'S,Jorge,C', String cr! !!SupplierImportTest methodsFor: 'instance creation' stamp: 'ndecarli 7/2/2018 14:34'!invalidSupplierFileWithMoreThanFourFieldsRecord    ^ReadStream on:     self supplierRecordWithMoreThanFourFieldsTestData,     self validNewCustomer1Data,     self validExistingCustomer1Data,     self validAddress1Data! !!SupplierImportTest methodsFor: 'instance creation' stamp: 'ndecarli 7/2/2018 14:35'!validNewCustomer2Data    ^'NC,Pepe,Sanchez,D,', self newCustomer2IdentificationNumber, String cr! !!SupplierImportTest methodsFor: 'instance creation' stamp: 'ndecarli 7/2/2018 15:51'!newCustomer1IdentificationNumber	^ '11', self existingCustomer1IdentificationNumber! !!SupplierImportTest methodsFor: 'instance creation' stamp: 'ndecarli 7/2/2018 14:25'!supplierRecordWithMoreThanFourFieldsTestData    ^'S,' , self validSupplierData! !!SupplierImportTest methodsFor: 'instance creation' stamp: 'ndecarli 7/2/2018 14:35'!validNewCustomer1Data    ^'NC,Pepe,Sanchez,D,', self newCustomer1IdentificationNumber, String cr! !!SupplierImportTest methodsFor: 'instance creation' stamp: 'ndecarli 7/2/2018 14:12'!validAddress2Data    ^'A,Maipu,888,Florida,1122,Buenos Aires', String cr! !!SupplierImportTest methodsFor: 'instance creation' stamp: 'ndecarli 7/2/2018 14:13'!validSupplierData    ^'S,Supplier1,D,123', String cr! !!SupplierImportTest methodsFor: 'instance creation' stamp: 'ndecarli 7/2/2018 15:53'!validExistingCustomer2Data    ^self validExistingCustomerDataWithIdNumer: self existingCustomer2IdentificationNumber.! !!SupplierImportTest methodsFor: 'instance creation' stamp: 'ndecarli 7/2/2018 15:51'!newCustomer2IdentificationNumber	^ '12', self existingCustomer1IdentificationNumber! !!SupplierImportTest methodsFor: 'instance creation' stamp: 'ndecarli 7/2/2018 15:54'!validExistingCustomer1Data    ^self validExistingCustomerDataWithIdNumer: self existingCustomer1IdentificationNumber.! !!SupplierImportTest methodsFor: 'instance creation' stamp: 'ndecarli 7/2/2018 14:34'!invalidSupplierFileWithLessThanFourFieldsRecord    ^ReadStream on:     self supplierRecordWithLessThanFourFieldsTestData,     self validNewCustomer1Data,     self validExistingCustomer1Data,     self validAddress1Data! !!SupplierImportTest methodsFor: 'instance creation' stamp: 'ndecarli 7/2/2018 15:53'!validExistingCustomerDataWithIdNumer: aNumberAsString    ^'EC,', self existingCustomerIdentificationType, ',', aNumberAsString, String cr! !!SupplierImportTest methodsFor: 'instance creation' stamp: 'ndecarli 7/2/2018 14:52'!validAddress1Data    ^'A,San Martin,3322,Olivos,1636,BsAs', String cr! !!SupplierImportTest methodsFor: 'initialization' stamp: 'MalenaIvnisky 7/2/2018 12:40'!setUp	customerSystem := Environment current createCustomerSystem.	customerSystem start.	customerSystem beginTransaction.		supplierSystem := Environment current createSupplierSystem.	supplierSystem start.	supplierSystem beginTransaction.! !!SupplierImportTest methodsFor: 'test data' stamp: 'ndecarli 7/2/2018 16:06'!validSupplierFileWithOneNewCustomer^ReadStream on: self validSupplierData,self validNewCustomer1Data,self validSupplierDefaultExistingCustomerData,self validSupplierDefaultAddressData! !!SupplierImportTest methodsFor: 'test data' stamp: 'ndecarli 7/2/2018 16:01'!validSupplierFileOnlyWithDefaultFullRecord	^ ReadStream on: self validSupplierDefaultFullRecord.! !!SupplierImportTest methodsFor: 'test data' stamp: 'ndecarli 7/2/2018 16:04'!validSupplierFileWithManyExistingCustomers^ReadStream on: self validSupplierData,self validSupplierDefaultNewCustomerData,self validExistingCustomer1Data,self validExistingCustomer2Data,self validSupplierDefaultAddressData! !!SupplierImportTest methodsFor: 'test data' stamp: 'ndecarli 7/2/2018 16:00'!validSupplierDefaultExistingCustomerData^self validExistingCustomer1Data! !!SupplierImportTest methodsFor: 'test data' stamp: 'ndecarli 7/2/2018 16:03'!validSupplierDefaultFullRecord^self validSupplierData,self validSupplierDefaultNewCustomerData,self validSupplierDefaultExistingCustomerData,self validSupplierDefaultAddressData! !!SupplierImportTest methodsFor: 'test data' stamp: 'ndecarli 7/2/2018 16:05'!validSupplierFileWithNoNewCustomers^ReadStream on: self validSupplierData,self validSupplierDefaultExistingCustomerData,self validSupplierDefaultAddressData! !!SupplierImportTest methodsFor: 'test data' stamp: 'ndecarli 7/2/2018 16:07'!validSupplierFileWithManyNewCustomers^ReadStream on: self validSupplierData,self validNewCustomer1Data,self validNewCustomer2Data,self validSupplierDefaultExistingCustomerData,self validSupplierDefaultAddressData! !!SupplierImportTest methodsFor: 'test data' stamp: 'ndecarli 7/2/2018 16:08'!validSupplierFileWithOneExistingCustomer^ReadStream on: self validSupplierData,self validSupplierDefaultNewCustomerData,self validExistingCustomer1Data,self validSupplierDefaultAddressData! !!SupplierImportTest methodsFor: 'test data' stamp: 'ndecarli 7/2/2018 16:00'!validSupplierDefaultNewCustomerData^self validNewCustomer1Data! !!SupplierImportTest methodsFor: 'test data' stamp: 'ndecarli 7/2/2018 16:07'!validSupplierFileWithManySupplierRecords	^ ReadStream on: self validSupplierDefaultFullRecord, 'S,Supplier2,C,23-25666777-9NC,Carlos,Tevez,C,', self newCustomer1IdentificationNumber, 'A,Diaz Velez,666,Almagro,666,BsAs', String cr! !!SupplierImportTest methodsFor: 'test data' stamp: 'ndecarli 7/2/2018 16:08'!validSupplierFileWithNoExistingCustomers^ReadStream on: self validSupplierData,self validSupplierDefaultNewCustomerData,self validSupplierDefaultAddressData! !!SupplierImportTest methodsFor: 'test data' stamp: 'ndecarli 7/2/2018 16:01'!validSupplierDefaultAddressData^self validAddress1Data,self validAddress2Data! !!SupplierImportTest methodsFor: 'tests' stamp: 'ndecarli 7/2/2018 16:18'!testImportSupplierWithManyExistingCustomers	self importValidExistingCustomer1.   self importValidExistingCustomer2.	self importSuppliersFrom: self validSupplierFileWithManyExistingCustomers.		self assertAmountOfSuccessfullyImportedSuppliersIs: 1.	self assertSupplier1HasCorrectDataAndNumberOfAddresses: self defaultNumberOfAddressesForSupplier1 andNumberOfCustomers: (self defaultNumberOfNewCustomersForSupplier1 + 2).	self assertSupplier1HasExistingCustomer1.	self assertSupplier1HasExistingCustomer2.	! !!SupplierImportTest methodsFor: 'tests' stamp: 'ndecarli 7/2/2018 16:13'!importValidExistingCustomer2	(CustomerImporter from: self validExistingTestDataOfCustomer2ForCustomerImporter using: customerSystem) import.	customerSystem commit.	customerSystem beginTransaction.	! !!SupplierImportTest methodsFor: 'tests' stamp: 'ndecarli 7/2/2018 14:22'!testCanNotImportSupplierRecordWithMoreThanFourFields	self		should: [ self				importSuppliersFrom: self invalidSupplierFileWithMoreThanFourFieldsRecord ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter invalidSupplierRecordErrorDescription.			self assert: supplierSystem isEmpty ]	! !!SupplierImportTest methodsFor: 'tests' stamp: 'ndecarli 7/2/2018 16:18'!testImportSupplierWithNoExistingCustomers	self importSuppliersFrom: self validSupplierFileWithNoExistingCustomers.		self assertAmountOfSuccessfullyImportedSuppliersIs: 1.	self assertSupplier1HasCorrectDataAndNumberOfAddresses: self defaultNumberOfAddressesForSupplier1 andNumberOfCustomers: self defaultNumberOfNewCustomersForSupplier1.	! !!SupplierImportTest methodsFor: 'tests' stamp: 'ndecarli 7/2/2018 15:49'!testImportSupplierWithOneNewCustomer		| amountOfExistingCustomers |		self importValidExistingCustomer1.	amountOfExistingCustomers := self amountOfStoredCustomers.		self importSuppliersFrom: self validSupplierFileWithOneNewCustomer.		self assertAmountOfSuccessfullyImportedSuppliersIs: 1.	self assertAmountOfStoredCustomersIs: (amountOfExistingCustomers + 1).	self assertSupplier1HasCorrectDataAndNumberOfAddresses: self defaultNumberOfAddressesForSupplier1 andNumberOfCustomers: (self defaultNumberOfExistingCustomersForSupplier1 + 1).	self assertSupplier1HasNewCustomer1.	! !!SupplierImportTest methodsFor: 'tests' stamp: 'ndecarli 7/2/2018 14:21'!testCanNotImportSupplierRecordWithLessThanFourFields	self		should: [ self				importSuppliersFrom: self invalidSupplierFileWithLessThanFourFieldsRecord ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter invalidSupplierRecordErrorDescription.			self assert: supplierSystem isEmpty ]	! !!SupplierImportTest methodsFor: 'tests' stamp: 'ndecarli 7/2/2018 16:07'!testImportManySuppliersSuccessfully		self importValidExistingCustomer1.	self importSuppliersFrom: self validSupplierFileWithManySupplierRecords.		self assertAmountOfSuccessfullyImportedSuppliersIs: 2.	self assertSupplier1WasImportedCorrectly.	self assertSupplier2WasImportedCorrectly.	! !!SupplierImportTest methodsFor: 'tests' stamp: 'MalenaIvnisky 6/29/2018 18:21'!importSuppliersFrom: inputStream	(SupplierImporter from: inputStream using: supplierSystem andCustomers: customerSystem) import! !!SupplierImportTest methodsFor: 'tests' stamp: 'ndecarli 7/2/2018 16:13'!importValidExistingCustomer1	(CustomerImporter from: self validExistingTestDataOfCustomer1ForCustomerImporter using: customerSystem) import.	customerSystem commit.	customerSystem beginTransaction.	! !!SupplierImportTest methodsFor: 'tests' stamp: 'ndecarli 7/2/2018 15:49'!testImportSupplierWithManyNewCustomers		| amountOfExistingCustomers |	self importValidExistingCustomer1.	amountOfExistingCustomers := self amountOfStoredCustomers.	self importSuppliersFrom: self validSupplierFileWithManyNewCustomers.		self assertAmountOfSuccessfullyImportedSuppliersIs: 1.	self assertAmountOfStoredCustomersIs: (amountOfExistingCustomers + 2).	self assertSupplier1HasCorrectDataAndNumberOfAddresses: self defaultNumberOfAddressesForSupplier1 andNumberOfCustomers: (self defaultNumberOfExistingCustomersForSupplier1 + 2).	self assertSupplier1HasNewCustomer1.	self assertSupplier1HasNewCustomer2.	! !!SupplierImportTest methodsFor: 'tests' stamp: 'ndecarli 7/2/2018 16:01'!testImportOneFullSupplierSuccessfully		self importValidExistingCustomer1.	self importSuppliersFrom: self validSupplierFileOnlyWithDefaultFullRecord.		self assertAmountOfSuccessfullyImportedSuppliersIs: 1.	self assertSupplier1WasImportedCorrectly.	! !!SupplierImportTest methodsFor: 'tests' stamp: 'ndecarli 7/2/2018 16:18'!testImportSupplierWithOneExistingCustomer	self importValidExistingCustomer1.	self importSuppliersFrom: self validSupplierFileWithOneExistingCustomer.		self assertAmountOfSuccessfullyImportedSuppliersIs: 1.	self assertSupplier1HasCorrectDataAndNumberOfAddresses: self defaultNumberOfAddressesForSupplier1 andNumberOfCustomers: (self defaultNumberOfNewCustomersForSupplier1 + 1).	self assertSupplier1HasExistingCustomer1.	! !!SupplierImportTest methodsFor: 'tests' stamp: 'ndecarli 7/2/2018 15:49'!testImportSupplierWithNoNewCustomers		| amountOfExistingCustomers |		self importValidExistingCustomer1.	amountOfExistingCustomers := self amountOfStoredCustomers.		self importSuppliersFrom: self validSupplierFileWithNoNewCustomers.		self assertAmountOfSuccessfullyImportedSuppliersIs: 1.	self assertAmountOfStoredCustomersIs: amountOfExistingCustomers.	self assertSupplier1HasCorrectDataAndNumberOfAddresses: self defaultNumberOfAddressesForSupplier1 andNumberOfCustomers: self defaultNumberOfExistingCustomersForSupplier1	! !!SupplierImportTest methodsFor: 'as yet unclassified' stamp: 'ndecarli 7/2/2018 15:51'!existingCustomer2IdentificationNumber	^'6324083'! !!SupplierImportTest methodsFor: 'as yet unclassified' stamp: 'ndecarli 7/2/2018 16:13'!validExistingTestDataOfCustomer2ForCustomerImporter	^ self validExistingTestDataForCustomerImporterWithIdNumber: self existingCustomer2IdentificationNumber.! !!SupplierImportTest methodsFor: 'as yet unclassified' stamp: 'ndecarli 7/2/2018 15:51'!existingCustomer1IdentificationNumber	^'5456774'! !!SupplierImportTest methodsFor: 'as yet unclassified' stamp: 'MaleyDK 7/2/2018 01:16'!existingCustomerIdentificationType	^'D'! !!SupplierImportTest methodsFor: 'as yet unclassified' stamp: 'MalenaIvnisky 7/2/2018 12:49'!existingCustomerName	^'Juan'! !!SupplierImportTest methodsFor: 'as yet unclassified' stamp: 'ndecarli 7/2/2018 16:12'!validExistingTestDataForCustomerImporterWithIdNumber: anIdNumber	^ ReadStream on: 'C,',		self existingCustomerName, ',',		self existingCustomerLastName, ',',		self existingCustomerIdentificationType, ',', 		anIdNumber, 		String cr! !!SupplierImportTest methodsFor: 'as yet unclassified' stamp: 'ndecarli 7/2/2018 16:13'!validExistingTestDataOfCustomer1ForCustomerImporter	^ self validExistingTestDataForCustomerImporterWithIdNumber: self existingCustomer1IdentificationNumber.! !!SupplierImportTest methodsFor: 'as yet unclassified' stamp: 'MalenaIvnisky 7/2/2018 12:49'!existingCustomerLastName	^'Perez'! !PartyImporter subclass: #SupplierImporter	instanceVariableNames: 'customerSystem supplierSystem'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!SupplierImporter methodsFor: 'testing' stamp: 'MalenaIvnisky 6/29/2018 17:25'!isSupplierRecord	^ record first = 'S'! !!SupplierImporter methodsFor: 'testing' stamp: 'MalenaIvnisky 6/29/2018 17:49'!isExistingCustomerRecord	^ record first = 'EC'! !!SupplierImporter methodsFor: 'testing' stamp: 'MalenaIvnisky 6/29/2018 17:49'!isNewCustomerRecord	^ record first = 'NC'! !!SupplierImporter methodsFor: 'importing - private' stamp: 'MaleyDK 7/2/2018 00:14'!importNewCustomer	| newCustomer |	self assertValidNewCustomerRecordSize.	self assertNewCustomerDoesntExist.	newCustomer := Customer new.	newCustomer firstName: record second.	newCustomer lastName: record third.	newCustomer identificationType: record fourth.	newCustomer identificationNumber: record fifth.	customerSystem add: newCustomer.	newParty addCustomer: newCustomer.! !!SupplierImporter methodsFor: 'importing - private' stamp: 'MaleyDK 7/2/2018 00:14'!importExistingCustomer	| existingCustomer |	self assertValidExistingCustomerRecordSize.	existingCustomer := customerSystem customerIdentifiedAs: (record second) numbered: (record third).	newParty addCustomer: existingCustomer.! !!SupplierImporter methodsFor: 'importing - private' stamp: 'MaleyDK 7/2/2018 00:46'!validPartyRecordSize	^ 4! !!SupplierImporter methodsFor: 'importing - private' stamp: 'MalenaIvnisky 6/29/2018 17:44'!importRecord		self isSupplierRecord ifTrue: [ ^self importSupplier ].	self isAddressRecord ifTrue: [ ^self importAddress ].	self isNewCustomerRecord ifTrue: [ ^self importNewCustomer ].	self isExistingCustomerRecord ifTrue: [ ^self importExistingCustomer ].		self signalInvalidRecordType! !!SupplierImporter methodsFor: 'importing - private' stamp: 'MaleyDK 7/2/2018 00:45'!importSupplier	self assertValidPartyRecordSize.	newParty := Supplier new.	newParty fullName: record second.	newParty identificationType: record third.	newParty identificationNumber: record fourth.	supplierSystem add: newParty! !!SupplierImporter methodsFor: 'signalling' stamp: 'MaleyDK 7/2/2018 00:28'!signalAddressWithoutPartyError	self error: self class addressWithoutSupplierErrorDescription.! !!SupplierImporter methodsFor: 'signalling' stamp: 'MaleyDK 7/2/2018 00:44'!signalInvalidPartyRecord 		self error: self class invalidSupplierRecordErrorDescription ! !!SupplierImporter methodsFor: 'signalling' stamp: 'MaleyDK 7/2/2018 00:58'!signalNewCustomerAlreadyExists 		self error: self class newCustomerAlreadyExistsErrorDescription ! !!SupplierImporter methodsFor: 'signalling' stamp: 'MalenaIvnisky 6/29/2018 18:02'!signalInvalidExistingCustomerRecord 		self error: self class invalidExistingCustomerRecordErrorDescription ! !!SupplierImporter methodsFor: 'signalling' stamp: 'MalenaIvnisky 6/29/2018 18:04'!signalInvalidNewCustomerRecord 		self error: self class invalidNewCustomerRecordErrorDescription ! !!SupplierImporter methodsFor: 'asserting' stamp: 'MalenaIvnisky 6/29/2018 18:04'!assertValidNewCustomerRecordSize		record size ~= 5 ifTrue: [ self signalInvalidNewCustomerRecord ].! !!SupplierImporter methodsFor: 'asserting' stamp: 'MalenaIvnisky 6/29/2018 18:02'!assertValidExistingCustomerRecordSize		record size ~= 3 ifTrue: [ self signalInvalidExistingCustomerRecord ].! !!SupplierImporter methodsFor: 'asserting' stamp: 'MaleyDK 7/2/2018 01:06'!assertNewCustomerDoesntExist	| idType idNumber |		idType := record second.	idNumber := record third.		[ customerSystem customerIdentifiedAs: idType numbered: idNumber ] 		on: Error		do: [ ^true ].			self signalNewCustomerAlreadyExists	! !!SupplierImporter methodsFor: 'initialization' stamp: 'MalenaIvnisky 6/29/2018 17:47'!initializeOn: aReadStream using: aSupplierSystem andCustomers: aCustomerSystem	readStream := aReadStream.	customerSystem := aCustomerSystem.	supplierSystem := aSupplierSystem.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SupplierImporter class	instanceVariableNames: ''!!SupplierImporter class methodsFor: 'instance creation' stamp: 'MaleyDK 7/2/2018 00:58'!newCustomerAlreadyExistsErrorDescription 		^'New customer already exists'! !!SupplierImporter class methodsFor: 'instance creation' stamp: 'MalenaIvnisky 6/29/2018 17:46'!from: aReadStream using: aSupplierSystem andCustomers: aCustomerSystem	^ self new initializeOn: aReadStream using: aSupplierSystem andCustomers: aCustomerSystem! !!SupplierImporter class methodsFor: 'error descriptions' stamp: 'MalenaIvnisky 6/29/2018 18:02'!invalidExistingCustomerRecordErrorDescription 		^'Invalid existing customer record'! !!SupplierImporter class methodsFor: 'error descriptions' stamp: 'MalenaIvnisky 6/29/2018 18:05'!invalidNewCustomerRecordErrorDescription 		^'Invalid new customer record'! !!SupplierImporter class methodsFor: 'error descriptions' stamp: 'MaleyDK 7/2/2018 00:27'!addressWithoutSupplierErrorDescription		^'There is no supplier for the imported address'! !!SupplierImporter class methodsFor: 'error descriptions' stamp: 'MalenaIvnisky 6/29/2018 17:35'!invalidSupplierRecordErrorDescription		^'Invalid supplier record'! !StorageSystem subclass: #TransientStorageSystem	instanceVariableNames: 'entities'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!TransientStorageSystem methodsFor: 'initialization' stamp: 'MalenaIvnisky 7/2/2018 11:31'!initialize		entities := OrderedCollection new! !!TransientStorageSystem methodsFor: 'customers' stamp: 'MalenaIvnisky 7/2/2018 11:28'!add: anEntity	entities add: anEntity! !!TransientStorageSystem methodsFor: 'customers' stamp: 'MalenaIvnisky 7/2/2018 11:31'!isEmpty	^ entities isEmpty ! !!TransientStorageSystem methodsFor: 'as yet unclassified' stamp: 'MalenaIvnisky 7/2/2018 11:51'!allEntities	^ entities copy! !!TransientStorageSystem methodsFor: 'as yet unclassified' stamp: 'MalenaIvnisky 7/2/2018 11:52'!partyIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber		^entities detect: [ :aCustomer | aCustomer isIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ]! !!TransientStorageSystem methodsFor: 'system live cycle' stamp: 'MalenaIvnisky 7/2/2018 11:32'!start	! !!TransientStorageSystem methodsFor: 'system live cycle' stamp: 'MalenaIvnisky 7/2/2018 11:32'!shutdown		! !!TransientStorageSystem methodsFor: 'transaction' stamp: 'MalenaIvnisky 7/2/2018 11:29'!commit		! !!TransientStorageSystem methodsFor: 'transaction' stamp: 'MalenaIvnisky 7/2/2018 11:29'!beginTransaction		! !TransientStorageSystem subclass: #TransientCustomerSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!TransientCustomerSystem methodsFor: 'customers' stamp: 'MalenaIvnisky 7/2/2018 11:52'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber		^self partyIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber! !!TransientCustomerSystem methodsFor: 'customers' stamp: 'MalenaIvnisky 7/2/2018 11:51'!allCustomers	^ self allEntities ! !TransientStorageSystem subclass: #TransientSupplierSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!TransientSupplierSystem methodsFor: 'as yet unclassified' stamp: 'MalenaIvnisky 7/2/2018 11:53'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	^ self partyIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber! !!TransientSupplierSystem methodsFor: 'as yet unclassified' stamp: 'MalenaIvnisky 7/2/2018 11:51'!allSuppliers	^ self allEntities ! !Object subclass: #ClassMapping	instanceVariableNames: 'mappedClass mappings tableName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!ClassMapping methodsFor: 'testing' stamp: 'HernanWilkinson 10/31/2016 23:02'!isFor: aClass	^mappedClass = aClass! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapEmbededOf: anObject into: record	mappings do: [ :aMapping | aMapping embeded: anObject into: record ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping mapOneToManyRelationshipsOf: anObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmap: aRecord into: unMappedObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping unmap: aRecord into: unMappedObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapIdOf: anObject into: record using: aDataBaseSession	| newId |	newId := aDataBaseSession newIdFor: anObject.	anObject instVarNamed: #id put: newId.	record at: #id put: newId! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmapIdOf: aRecord into: unMappedObject	unMappedObject instVarNamed: #id put: (aRecord at: #id)! !!ClassMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:25'!initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings	mappedClass := aClass.	tableName := aTableName.	mappings := aCollectionOfMappings ! !!ClassMapping methodsFor: 'table' stamp: 'HernanWilkinson 10/31/2016 23:25'!tableName		^tableName ! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:40'!map: anObject using: aDataBaseSession	| record |	self toDo: 'se puede optimizar usando array para registros y guardando definicion de tabla una vez'.	record := Dictionary new.		self mapIdOf: anObject into: record using: aDataBaseSession.	self mapEmbededOf: anObject into: record.	"agrego aca el registro y no luego de mapear el id para que lo agrege completo. Lo agrego antes de mapear las rel one to many 	porque si usuara una db de verdad habria foreign key constrain"	aDataBaseSession add: record on: self tableName.	self mapOneToManyRelationshipsOf: anObject using: aDataBaseSession! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:42'!unmap: aRecord using: aDataBaseSession	| unMappedObject |	unMappedObject := mappedClass basicNew.	self unmapIdOf: aRecord into: unMappedObject.	self unmap: aRecord into: unMappedObject using: aDataBaseSession.	^ unMappedObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ClassMapping class	instanceVariableNames: ''!!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:24'!for: aClass into: aTableName mappingAll: aCollectionOfMappings	self assertValidTableName: aTableName.	self assertHasIdInstanceVariable: aClass.	self assertValidMappings: aCollectionOfMappings for: aClass.		^self new initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings		! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:44'!defaultTableNameFor: aClass		^aClass name asString! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:23'!withDefaultTableNameFor: aClass mappingAll: aCollectionOfMappings	^self for: aClass into: (self defaultTableNameFor: aClass) mappingAll: aCollectionOfMappings		! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 19:26'!assertValidMappings: aCollectionOfMappings for: aClass 	self toDo: 'Lo mejor seria recolectar todos los erroes de mapeo y no parar en el primero'.	aCollectionOfMappings do: [ :aMapping | aMapping assertIsValidFor: aClass ]	! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidTableName: aTableName	aTableName trimBoth isEmpty ifTrue: [ self error: 'Table name can not be empty' ]! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 21:15'!assertHasIdInstanceVariable: aClass 		(aClass hasInstVarNamed: #id) ifFalse: [ self error: ('<1s> has no id instance variable' expandMacrosWith: aClass name) ]! !Object subclass: #DataBaseSession	instanceVariableNames: 'configuration tables id cache'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 10/31/2016 22:17'!selectAllOfType: aClass 		^self select: [ :anObject | true ] ofType: aClass! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:26'!select: aCondition ofType: aClass	| mapper table |	self assertInTransaction.	self delay.		mapper := self mapperFor: aClass.	table := tables at: mapper tableName ifAbsent: [ ^ #() ].		^ table inject: OrderedCollection new into: [ :selected :record | self addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper ]! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:15'!objectIdentifiedAs: anId ofType: aClass	self assertInTransaction.	self delay.		^ cache at: anId ifAbsentPut: [ self unmapRecordIdentifiedAs: anId ofType: aClass ]! !!DataBaseSession methodsFor: 'persistance' stamp: 'HernanWilkinson 11/1/2016 01:28'!persist: anObject	| mapper |		self assertInTransaction.	self delay.		mapper := self mapperFor: anObject class.	mapper map: anObject using: self.		self addToCache: anObject ! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 11/4/2016 09:52'!shutdown	self assertIsOpen.		tables := nil! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 11/4/2016 09:51'!start	self assertIsClose.		tables := Dictionary new.	! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!assertIsOpen		tables isNil ifTrue: [ self error: 'Session must be open to colaborate with it' ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:37'!assertIsClose		tables isNil ifFalse: [ self error: 'Session must be close' ]! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableFor: anOwnerClass relatedTo: aRelatedClass	| relationTableName table |	relationTableName := self relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass.	table := self tableNamed: relationTableName.		^ table! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 00:48'!tableNamed: aTableName	^ tables at: aTableName ifAbsentPut: [ Dictionary new ]! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass	| ownerClassMapper relatedClassMapper |		ownerClassMapper := self mapperFor: anOwnerClass.	relatedClassMapper := self mapperFor: aRelatedClass.		^ownerClassMapper tableName,'_', relatedClassMapper tableName asPlural.! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:16'!unmapRecordIdentifiedAs: anId ofType: aClass	| record table mapper |	mapper := self mapperFor: aClass.	table := self tableNamed: mapper tableName.	record := table at: id ifAbsent: [ self error: ('Object identified as <1s> does not exist' expandMacrosWith: anId printString) ].		^ mapper unmap: record using: self! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:15'!relatedOfType: aRelatedClass for: anOwner	| table relatedIds |		table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := table at: (self idOf: anOwner) ifAbsent: [ ^#() ].		^relatedIds collect: [ :aRelatedId | self objectIdentifiedAs: aRelatedId ofType: aRelatedClass ]		! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:14'!mapperFor: aClass	self toDo: 'se puede mejorar performanco usando un dictionary'.	^configuration		detect: [ :aClassMapper | aClassMapper isFor: aClass ] 		ifNone: [ self error: ('There is no mapper for <1s>' expandMacrosWith: aClass name) ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:06'!relatedIdOwnedBy: anOwner on: table	^ table at: (self idOf: anOwner) ifAbsentPut: [ Set new ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:00'!signalRelationAlreadyExistBetween: anOwner and: aRelated 	self error: ('Relation between id <1s> of type <2s> and id <3s> of type <4s> already exist'		expandMacrosWith: (self idOf: anOwner) printString		with: anOwner class name		with: (self idOf: aRelated) printString		with: aRelated class name)! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:27'!addToCache: anObject 	cache at: (self idOf: anObject) put: anObject ! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:05'!assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds	(relatedIds includes: relatedId) ifTrue: [ self signalRelationAlreadyExistBetween: anOwner and: aRelated ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!addRelated: aRelated ownedBy: anOwner	| relatedIds relatedId |	relatedIds := self relatedIdsOwnedBy: anOwner forType: aRelated class.	relatedId := aRelated instVarNamed: #id.	self assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds.		relatedIds add: relatedId! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!add: aRecord on: aTableName	| table existingRecord |	table := self tableNamed: aTableName.	existingRecord := table at: (self recordId: aRecord) ifAbsentPut: [ aRecord ].	existingRecord == aRecord ifFalse: [ self error: 'Duplicated primary key' ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:10'!relatedIdsOwnedBy: anOwner forType: aRelatedClass	| relatedIds table |	table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := self relatedIdOwnedBy: anOwner on: table.		^ relatedIds! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!beginTransaction	self assertIsOpen.	self assertNotInTransasction.		cache := WeakKeyDictionary new.	! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!commit		self assertInTransaction.		cache := nil! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertInTransaction		cache isNil ifTrue: [ self error: 'There is no transaction currently' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertNotInTransasction		cache notNil ifTrue: [ self error: 'There is an open transaction already' ]! !!DataBaseSession methodsFor: 'selecting - private' stamp: 'HernanWilkinson 11/1/2016 01:28'!addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper	| recordId aClassInstance |	recordId := self recordId: record.	aClassInstance := cache at: recordId ifAbsent: [ mapper unmap: record using: self ].	(aCondition value: aClassInstance) ifTrue: [ 		self addToCache: aClassInstance.		selected add: aClassInstance ].		^ selected! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:35'!defineIdOf: anObject	anObject instVarNamed: 'id' put: (self newIdFor: anObject).! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:41'!delay	(Delay forMilliseconds: 100) wait! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 10/28/2016 16:35'!newIdFor: anObject	id := id + 1.	^id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:00'!idOf: anObject	^anObject instVarNamed: #id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:04'!recordId: aRecord	^aRecord at: #id! !!DataBaseSession methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 22:55'!initializeFor: aConfiguration	configuration := aConfiguration.	id := 0.	tables := nil.	cache := nil.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DataBaseSession class	instanceVariableNames: ''!!DataBaseSession class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/28/2016 13:07'!for: aConfiguration	^self new initializeFor: aConfiguration! !Object subclass: #Mapping	instanceVariableNames: 'instanceVariableName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!Mapping methodsFor: 'assertions' stamp: 'MalenaIvnisky 7/2/2018 11:47'!assertIsValidFor: aClass 	((aClass hasInstVarNamed: instanceVariableName) or: [ aClass superclass hasInstVarNamed: instanceVariableName]) ifFalse: [ 		self error: ('Invalid mapping for <1s> in class <2s>' expandMacrosWith: instanceVariableName with: aClass name) ] ! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!unmap: aRecord into: anObject using: aDataBaseSession	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!embeded: anObject into: aRecord	self subclassResponsibility! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Mapping class	instanceVariableNames: ''!!Mapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 01:32'!defaultFieldNameFor: anInstanceVariableName	^anInstanceVariableName asString! !!Mapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidFieldName: aFieldName	aFieldName trimBoth isEmpty ifTrue: [ self error: 'Field name can not be empty' ]! !Mapping subclass: #EmbededMapping	instanceVariableNames: 'fieldName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!unmap: aRecord into: anObject using: aDataBaseSession 	anObject instVarNamed: instanceVariableName put: (aRecord at: fieldName)! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:23'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession 		! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!embeded: anObject into: aRecord	aRecord at: fieldName put: (anObject instVarNamed: instanceVariableName) ! !!EmbededMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:30'!initializeFor: anInstanceVariableName into: aFieldName	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EmbededMapping class	instanceVariableNames: ''!!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:29'!withDefaultFieldNameFor: anInstanceVariableName	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName)! !!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:30'!for: anInstanceVariableName into: aFieldName	^self new initializeFor: anInstanceVariableName into: aFieldName ! !Mapping subclass: #OneToManyMapping	instanceVariableNames: 'relatedType fieldName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:35'!createRelationCollectionOn: aDataBaseSession ownedBy: anObject	^ OneToManySet on: aDataBaseSession ownedBy: anObject! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!unmap: aRecord into: anObject using: aDataBaseSession	| newCollection related |	related := aDataBaseSession relatedOfType: relatedType for: anObject.	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	newCollection addAllNotPersisting: related.	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	| oldCollection newCollection |	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	oldCollection := anObject instVarNamed: instanceVariableName.		newCollection addAll: oldCollection.	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:16'!embeded: anObject into: aRecord	! !!OneToManyMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:34'!initializeFor: anInstanceVariableName into: aFieldName ofType: aClass	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName.	relatedType := aClass ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManyMapping class	instanceVariableNames: ''!!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:40'!for: anInstanceVariableName into: aFieldName ofType: aClass	self assertValidFieldName: aFieldName.		^self new initializeFor: anInstanceVariableName into: aFieldName ofType: aClass! !!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:32'!withDefaultFieldNameFor: anInstanceVariableName ofType: aClass	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName) ofType: aClass! !Set subclass: #OneToManySet	instanceVariableNames: 'session owner'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:03'!addAllNotPersisting: aCollection 		^aCollection do: [ :anObjectToAdd | super add: anObjectToAdd ]! !!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:11'!add: anObject	session persist: anObject.	session addRelated: anObject ownedBy: owner.		super add: anObject.! !!OneToManySet methodsFor: 'removing' stamp: 'HernanWilkinson 10/31/2016 21:35'!remove: anObject ifAbsent: anAbsentBlock	self shouldBeImplemented ! !!OneToManySet methodsFor: 'initialization' stamp: 'HernanWilkinson 11/1/2016 00:11'!initializeOn: aDataBaseSession ownedBy: anOwner		session := aDataBaseSession.	owner := anOwner ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManySet class	instanceVariableNames: ''!!OneToManySet class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:11'!on: aDataBaseSession ownedBy: anOwner		^self new initializeOn: aDataBaseSession ownedBy: anOwner ! !'From Pharo6.0 of 13 May 2016 [Latest update: #60541] on 2 July 2018 at 4:19:06.250711 pm'!!String methodsFor: '*IS1-CustomerImport' stamp: 'HernanWilkinson 10/31/2016 23:57'!asPlural		^self last = $s 		ifTrue: [ self, 'es' ]		ifFalse: [ self, 's' ]! !'From Pharo6.0 of 13 May 2016 [Latest update: #60541] on 2 July 2018 at 4:19:06.252711 pm'!!Object methodsFor: '*IS1-CustomerImport' stamp: 'HernanWilkinson 10/31/2016 19:27'!toDo: aString 	! !